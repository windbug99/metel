from __future__ import annotations

import argparse
import json
import pathlib
import re
from dataclasses import dataclass

ALLOWED_ENV_KEYS = {
    "SKILL_ROUTER_V2_ENABLED",
    "SKILL_RUNNER_V2_ENABLED",
    "SKILL_V2_SHADOW_MODE",
    "SKILL_V2_TRAFFIC_PERCENT",
}

_ENV_LINE_RE = re.compile(r"^([A-Za-z_][A-Za-z0-9_]*)=(.*)$")


@dataclass
class ApplyResult:
    updated: dict[str, tuple[str | None, str]]
    skipped: list[str]
    untouched: int


def _load_suggested_env(path: pathlib.Path) -> dict[str, str]:
    payload = json.loads(path.read_text(encoding="utf-8"))
    suggested = payload.get("suggested_env")
    if not isinstance(suggested, dict):
        return {}
    out: dict[str, str] = {}
    for key, value in suggested.items():
        env_key = str(key or "").strip()
        env_value = str(value or "").strip()
        if env_key and env_value:
            out[env_key] = env_value
    return out


def _read_env_lines(path: pathlib.Path) -> list[str]:
    if not path.exists():
        return []
    return path.read_text(encoding="utf-8").splitlines()


def _write_env_lines(path: pathlib.Path, lines: list[str]) -> None:
    content = "\n".join(lines).rstrip() + "\n"
    path.write_text(content, encoding="utf-8")


def _apply_to_lines(lines: list[str], suggested_env: dict[str, str]) -> ApplyResult:
    target = {k: v for k, v in suggested_env.items() if k in ALLOWED_ENV_KEYS}
    skipped = [k for k in suggested_env.keys() if k not in ALLOWED_ENV_KEYS]

    updated: dict[str, tuple[str | None, str]] = {}
    seen_keys: set[str] = set()
    out: list[str] = []

    for line in lines:
        m = _ENV_LINE_RE.match(line.strip())
        if not m:
            out.append(line)
            continue
        key, old_value = m.group(1), m.group(2)
        if key in target:
            new_value = target[key]
            seen_keys.add(key)
            if old_value != new_value:
                updated[key] = (old_value, new_value)
                out.append(f"{key}={new_value}")
            else:
                out.append(line)
            continue
        out.append(line)

    for key, value in target.items():
        if key in seen_keys:
            continue
        updated[key] = (None, value)
        out.append(f"{key}={value}")

    lines.clear()
    lines.extend(out)
    return ApplyResult(updated=updated, skipped=skipped, untouched=len(target) - len(updated))


def main() -> int:
    parser = argparse.ArgumentParser(description="Apply Skill V2 rollout decision JSON to .env file")
    parser.add_argument(
        "--from-json",
        type=str,
        default="../docs/reports/skill_v2_rollout_decision_latest.json",
        help="Path to JSON generated by decide_skill_v2_rollout.py",
    )
    parser.add_argument(
        "--env-file",
        type=str,
        default=".env",
        help="Target env file path",
    )
    parser.add_argument(
        "--apply",
        action="store_true",
        help="Actually write changes. Without this flag it runs in dry-run mode.",
    )
    args = parser.parse_args()

    json_path = pathlib.Path(args.from_json).resolve()
    env_path = pathlib.Path(args.env_file).resolve()

    suggested_env = _load_suggested_env(json_path)
    if not suggested_env:
        print("[apply-rollout] no suggested_env found")
        return 0

    lines = _read_env_lines(env_path)
    result = _apply_to_lines(lines, suggested_env)

    print("[apply-rollout] preview")
    print(f"- target env file: {env_path}")
    print(f"- suggested keys: {len(suggested_env)}")
    print(f"- applied candidates: {len(result.updated)}")
    print(f"- unchanged: {result.untouched}")
    if result.skipped:
        print("- skipped (not allowlisted):")
        for key in result.skipped:
            print(f"  - {key}")
    if result.updated:
        print("- changes:")
        for key, (old, new) in result.updated.items():
            if old is None:
                print(f"  - {key}: <missing> -> {new}")
            else:
                print(f"  - {key}: {old} -> {new}")
    else:
        print("- changes: none")

    if not args.apply:
        print("[apply-rollout] dry-run complete (use --apply to write)")
        return 0

    _write_env_lines(env_path, lines)
    print("[apply-rollout] applied")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
