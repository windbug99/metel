from __future__ import annotations

import argparse
import json
import pathlib
import re
from dataclasses import dataclass


ALLOWED_ENV_KEYS = {
    "LLM_AUTONOMOUS_MAX_TURNS",
    "LLM_AUTONOMOUS_MAX_TOOL_CALLS",
    "LLM_AUTONOMOUS_TIMEOUT_SEC",
    "LLM_AUTONOMOUS_REPLAN_LIMIT",
    "LLM_AUTONOMOUS_LIMIT_RETRY_ONCE",
    "LLM_AUTONOMOUS_RULE_FALLBACK_ENABLED",
    "LLM_AUTONOMOUS_RULE_FALLBACK_MUTATION_ENABLED",
    "LLM_AUTONOMOUS_PROGRESSIVE_NO_FALLBACK_ENABLED",
    "LLM_AUTONOMOUS_STRICT_TOOL_SCOPE",
    "LLM_HYBRID_EXECUTOR_FIRST",
    "LLM_PLANNER_RULE_FALLBACK_ENABLED",
    "TOOL_SPECS_VALIDATE_ON_STARTUP",
}

_ENV_LINE_RE = re.compile(r"^([A-Za-z_][A-Za-z0-9_]*)=(.*)$")


@dataclass
class ApplyResult:
    updated: dict[str, tuple[str | None, str]]
    skipped: list[str]
    untouched: int


def _load_policy_recommendations(path: pathlib.Path) -> list[dict[str, str]]:
    payload = json.loads(path.read_text(encoding="utf-8"))
    recs = payload.get("policy_recommendations")
    if not isinstance(recs, list):
        return []
    normalized: list[dict[str, str]] = []
    for item in recs:
        if not isinstance(item, dict):
            continue
        env_key = str(item.get("env_key", "")).strip()
        suggested_value = str(item.get("suggested_value", "")).strip()
        reason = str(item.get("reason", "")).strip()
        if env_key and suggested_value:
            normalized.append(
                {
                    "env_key": env_key,
                    "suggested_value": suggested_value,
                    "reason": reason,
                }
            )
    return normalized


def _load_policy_recommendations_from_paths(paths: list[pathlib.Path]) -> list[dict[str, str]]:
    merged: list[dict[str, str]] = []
    seen: set[tuple[str, str]] = set()
    for path in paths:
        if not path.exists():
            continue
        for item in _load_policy_recommendations(path):
            key = (item["env_key"], item["suggested_value"])
            if key in seen:
                continue
            seen.add(key)
            merged.append(item)
    return merged


def _read_env_lines(path: pathlib.Path) -> list[str]:
    if not path.exists():
        return []
    return path.read_text(encoding="utf-8").splitlines()


def _write_env_lines(path: pathlib.Path, lines: list[str]) -> None:
    content = "\n".join(lines).rstrip() + "\n"
    path.write_text(content, encoding="utf-8")


def _apply_recommendations_to_lines(lines: list[str], recs: list[dict[str, str]]) -> ApplyResult:
    target = {
        item["env_key"]: item["suggested_value"]
        for item in recs
        if item.get("env_key") in ALLOWED_ENV_KEYS
    }
    skipped = [
        item.get("env_key", "")
        for item in recs
        if item.get("env_key") and item.get("env_key") not in ALLOWED_ENV_KEYS
    ]

    updated: dict[str, tuple[str | None, str]] = {}
    seen_keys: set[str] = set()
    out: list[str] = []

    for line in lines:
        m = _ENV_LINE_RE.match(line.strip())
        if not m:
            out.append(line)
            continue
        key, old_value = m.group(1), m.group(2)
        if key in target:
            new_value = target[key]
            seen_keys.add(key)
            if old_value != new_value:
                updated[key] = (old_value, new_value)
                out.append(f"{key}={new_value}")
            else:
                out.append(line)
            continue
        out.append(line)

    # append missing keys
    for key, value in target.items():
        if key in seen_keys:
            continue
        updated[key] = (None, value)
        out.append(f"{key}={value}")

    lines.clear()
    lines.extend(out)
    return ApplyResult(updated=updated, skipped=skipped, untouched=len(target) - len(updated))


def main() -> int:
    parser = argparse.ArgumentParser(description="Apply policy_recommendations from agent quality JSON to .env file")
    parser.add_argument(
        "--from-json",
        type=str,
        action="append",
        default=[],
        help="Path to JSON generated by eval_agent_quality.py",
    )
    parser.add_argument(
        "--env-file",
        type=str,
        default=".env",
        help="Target env file path (default: backend/.env when run from backend dir)",
    )
    parser.add_argument(
        "--apply",
        action="store_true",
        help="Actually write changes. Without this flag it runs in dry-run mode.",
    )
    args = parser.parse_args()

    json_paths = [pathlib.Path(path).resolve() for path in args.from_json]
    if not json_paths:
        json_paths = [pathlib.Path("../docs/reports/agent_quality_latest.json").resolve()]
    env_path = pathlib.Path(args.env_file).resolve()

    recs = _load_policy_recommendations_from_paths(json_paths)
    if not recs:
        print("[apply-policy] no policy_recommendations found")
        return 0

    lines = _read_env_lines(env_path)
    result = _apply_recommendations_to_lines(lines, recs)

    print("[apply-policy] preview")
    print(f"- target env file: {env_path}")
    print(f"- source reports: {', '.join(str(path) for path in json_paths)}")
    print(f"- recommendations: {len(recs)}")
    print(f"- applied candidates: {len(result.updated)}")
    print(f"- unchanged: {result.untouched}")
    if result.skipped:
        print("- skipped (not allowlisted):")
        for key in result.skipped:
            print(f"  - {key}")
    if result.updated:
        print("- changes:")
        for key, (old, new) in result.updated.items():
            if old is None:
                print(f"  - {key}: <missing> -> {new}")
            else:
                print(f"  - {key}: {old} -> {new}")
    else:
        print("- changes: none")

    if not args.apply:
        print("[apply-policy] dry-run complete (use --apply to write)")
        return 0

    _write_env_lines(env_path, lines)
    print("[apply-policy] applied")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
